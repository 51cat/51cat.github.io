---
title: 开发规划
categories: [代谢]
tags: [develop]     # TAG names should always be lowercase
---

# 开发记录 2023.11.4-2023.11.5

## 流程基本框架搭建

- ✔学习项目开发规范
- ✔io
- ✔log
- ✔规定流程内代码格式

### io

本部分的作用是使用统一的接口对传入的参数进行检查，储存，调用和加载（参考了R中的泛函的实现），目的是方便后续的开发过程中对不同的数据和参数进行管理

示例如下：

所有的传入参数都存在`IO`的实例中，通过`io_objective.propety`的形式调用

- 读取fasta

```python
from modAna.core.io import IO

fasta_file = "/path/to/my.fa"
# 构建对象
 test = IO(
        file=fasta_file,
        analysis_use="some_analysis1",
        outdir="./",
     	# 其他参数
        method1 = "a",
 )
# 检查和加载数据
 test.check()
 test.load()
 input_data, ana_type = tester.get_input()
```

- 读取模型

```python
from modAna.core.io import IO

fasta_file = "/path/to/model.xml"
# 构建对象
 test = IO(
        file=fasta_file,
        analysis_use="some_analysis2",
        outdir="./",
     	# 其他参数
        method2 = "b",
     	args2 = "special args",
 )
 # 检查和加载数据
 test.check()
 test.load()
 input_data, ana_type = test.get_input()
```

### log

本部分作用是用于记录软件的运行情况，使用装饰器实现，可以非常方便的实现对任意函数的运行情况进行记录、debug，同时可以实现输出函数内的任意运行信息，示例如下：

```python
from modAna.core.log import add_log

@add_log
def test_model_io():
    # model
    model_file = "/path/to/model.xml"
    tester = IO(
        file=model_file,
        analysis_use="knock_out",
        outdir="./",
        method1 = "a",
        method2 = "b"
    )
    tester.check()
    tester.load()
    test_model_io.logger.warning("test warning!")
    test_model_io.logger.error("test error!")
    input_data, ana_type = tester.get_input()
```

例如以下输出：

![](https://51catgithubio.oss-cn-beijing.aliyuncs.com/202311051647463.png)

### 流程内代码格式

流程的结构如下

![image-20231105165054792](https://51catgithubio.oss-cn-beijing.aliyuncs.com/202311051650828.png)

1. 每个分析模块都必须包含以下四个模块，每个分析都是独立可复用的模块

`io_{analysis_name}.py`：用于分析模块的参数输入，生成io类的实例

`ana_{analysis_name}.py`：具体的分析代码

`run_{analysis_name}.py`：用于调用本分析模块的代码，python内的调用入口

`cmd_{analysis_name}.py`：用于调用本分析模块的代码，命令行的调用入口

2. 公用代码：放在`tools`内

## 先前的代码整理和项目规划

✔学习项目开发规范

✔代码整理

✔项目规划

对先前的分析，包括基因敲除，最小基因集，代谢流，prokka部分、模型统计这些做了一个输出和输出的总结和梳理：

### 规划

**基本就按照下面的顺序去开发了**

基因敲除 ➡️ 最小基因集 ➡️ 模型统计 ➡️ 代谢流 ➡️ prokka

### 基因敲除

#### 输入

模型文件

基因list文件

物种信息

method：默认fba

solution：默认glapk

#### 输出

基因敲除的结果 - 表格形式呈现

基因的注释结果

对每个基因的一个统计结果

### 最小基因集

#### 输入

模型文件

物种信息

**geptop2参数:**

1. 蛋白序列

2. essentiality score cutoff（判定阈值）

3. 输出文件名（无用参数，需要修改源码，不然输出非常混乱）

   ps： 内部一些写死的东西也需要修改

#### 输出

最小基因集的结果

基因的注释结果

geptop2结果

### 模型统计

#### 输入

- 模型文件

#### 输出

- 模型内的基因信息

- 模型内的反应信息

- 模型内反应分类信息

### 代谢流

公共：model文件

#### 输入（FBA）

1. 生物质反应，可以自定义目标反应
2. 求解类型：默认maximize，可以自定义maximize或minimize

#### 输出（FBA）

1. 目标反应的最优解 数值
2. 详细信息

<img src="https://51catgithubio.oss-cn-beijing.aliyuncs.com/202311051647782.png" alt="d8822dfccf38423c064fbfd361a4833" style="zoom:67%;" />



#### 输入（FVA）

1. 默认是生物质反应，可以自定义目标反应
2. 求解类型：默认maximize，可以自定义maximize或minimize
3. 默认是全部反应进行分析，提供的话使用提供的列表进行分析

#### 输出（FVA）

表格：第一列反应，第二列最小值，第三列最大值，代表在求最优解的过程中，每个反应的变化范围

<img src="https://51catgithubio.oss-cn-beijing.aliyuncs.com/202311051647575.png" alt="dea79056370743a0b20791571991acc" style="zoom: 67%;" />

#### 输入（DFBA）

1. 动力学变量及条件: 这里需提供一个3列的tsv表格;第一列为动力学变名称(物质名称)第二列为变量的下限(指的是能够输入模型的最大通量)第三列为物质的初始浓度, 例如，

   ```
   name lower	start
   h2o		1	2
   ```

2. 总模拟时间: 默认24h

3. 模拟间隔：默认0.1h

#### 输出

1. 表格：每个物质随着时间变化的浓度值



2. <img src="https://51catgithubio.oss-cn-beijing.aliyuncs.com/202311051647892.png" alt="image-20231105154655467" style="zoom:50%;" />

### prokka

#### 输入

- 基因组序列
- prokka参数
- 目前来看比较关键的参数如下：
  1. prefix
  2. kingdom：Annotation mode: Archaea|Bacteria|Mitochondria|Viruses
  3. evalue：Similarity e-value cut-off
  4. coverage：Minimum coverage on query protein
  5. metagenome
  6. addgenes

最小基因集的结果

#### 输出

- 注释的结果，gff，gtf， 蛋白序列....

